use bevy_args::{parse_args, Deserialize, Parser, Serialize};
use burn::record::{FullPrecisionSettings, NamedMpkFileRecorder, Recorder};
use burn_import::pytorch::{LoadArgs, PyTorchFileRecorder};

// Note: DepthProRecord will be auto-generated by the #[derive(Module)] macro
// once the model structure is fully implemented
use burn_depth_pro::model::depth_pro::DepthProConfig;

#[derive(Clone, Debug, Default, Serialize, Deserialize, Parser)]
#[command(about = "burn_depth_pro import", version, long_about = None)]
pub struct DepthProImportConfig {
    #[arg(long, default_value = "./assets/models/depth_pro.pth")]
    pub weights_path: String,

    #[arg(long, default_value = "./assets/models/depth_pro")]
    pub output_path: String,
}

type Backend = burn::backend::NdArray<f32>;

fn main() {
    let args = parse_args::<DepthProImportConfig>();

    println!("Import tool for burn_depth_pro");
    println!("This tool will be functional once the DepthPro model is fully implemented.");
    println!("Configured to load from: {}", args.weights_path);
    println!("Configured to save to: {}", args.output_path);

    // TODO: Uncomment once DepthProRecord is available
    // let device = Default::default();
    // let load_args = LoadArgs::new(args.weights_path.into()).with_debug_print();
    // let record: DepthProRecord<Backend> = PyTorchFileRecorder::<FullPrecisionSettings>::default()
    //     .load(load_args, &device)
    //     .expect("failed to decode state");
    // let recorder = NamedMpkFileRecorder::<FullPrecisionSettings>::default();
    // recorder
    //     .record(record, args.output_path.into())
    //     .expect("failed to save model record");

    println!("Model import not yet implemented - waiting for full model structure.");
}
